<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Let's Go Exploring!]]></title><description><![CDATA[notes on aws, android and hacks.]]></description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Sun, 20 Dec 2015 03:57:36 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[How AWS Lambda made me a better cloud developer?]]></title><description><![CDATA[<p>AWS Lambda is a pretty <a href="http://www.engindogusoy.com/aws-lambda-missing-piece-of-aws-orchestration/">big deal</a> both for devops and REST APIs. It is a simple promise; instead of running a machine at all times to compute when needed, start a machine (fast!) when needed and release it after computation is done. Health checks, monitoring, scaling and even security</p>]]></description><link>http://localhost:2368/how-aws-lambda-made-me-a-better-programmer/</link><guid isPermaLink="false">145f4ce1-9f57-459e-9995-06d06eb76ba8</guid><category><![CDATA[lambda]]></category><category><![CDATA[aws]]></category><category><![CDATA[ami]]></category><dc:creator><![CDATA[Engin Dogusoy]]></dc:creator><pubDate>Sun, 20 Dec 2015 03:38:26 GMT</pubDate><content:encoded><![CDATA[<p>AWS Lambda is a pretty <a href="http://www.engindogusoy.com/aws-lambda-missing-piece-of-aws-orchestration/">big deal</a> both for devops and REST APIs. It is a simple promise; instead of running a machine at all times to compute when needed, start a machine (fast!) when needed and release it after computation is done. Health checks, monitoring, scaling and even security (in some cases) problems are things of the past and you have more resources to focus on your value proposition. </p>

<p>After spending some time with Lambda I've realized that its on demand nature forces good cloud development rules and saves developers from some common pitfalls.</p>

<h5 id="everythingisvolatile">Everything is volatile</h5>

<p>People like hacks, especially when things are on fire. When your servers start to go down, "I'll connect to the server and change/install/stop &#95;&#95;&#95;&#95;" would be one of the first responses you'll hear. You can fill the gap with a configuration, a monitoring tool or even a tiny local database. You should say NO. None of the changes will be carried to new instances, existing and future instances will be different from one another and worst if your setup includes an auto-scaling group AWS might choose to shut down your oldest instance, the one most likely to have extra stuff, when it is time to scale down.</p>

<p>If you want something to run in your servers it should be a part of your <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html">AWS AMI</a> and all of your active instances should be started with the same AMI. Your instances should NEVER handle persistence, unless they are specifically designed to do that, not even for small static stuff. I also like to prohibit key based SSH access to ElasticBeanstalk environments I manage.</p>

<p>With Lambda, you don't have access to rest of the system. You can't save stuff locally, you don't know where your code is running so you can't access to underlying machine. You have to work in scope and persist anything outside of Lambda.</p>

<h5 id="singleresponsibility">Single responsibility</h5>

<p>When you have a machine running at all times and don't have a great deal of requests, it is tempting to deploy more stuff on the same machine. I am not talking about improving the same functionality but deploying other functionalities and even unrelated systems on the same machine. Result; monolithic applications and/or multiple applications on the same machine, a coupling and debugging hell.</p>

<p>With Lambda your code is decoupled from everything else, it only exists at the time of execution.</p>

<h5 id="optimizationmatters">Optimization matters</h5>

<p>Lambda is priced by number of executions, reserved memory and execution duration. You need to make sure your Lambda code runs in the shortest time possible and is memory light. In Lambda pretty much nothing is premature optimization.</p>

<p>In the early days of your newly built backend the demand might not be high and you may skip optimizing number of calls from clients to the backend. In addition to creating scaling problems, unoptimized mobile clients bring hidden battery and network costs to your users. To keep number of Lambda invocations low, you might want to start with caching.</p>

<h5 id="neverassumeanything">Never assume anything</h5>

<p>You may not be looking for global domination in the near future. Your servers might not be distributed and you may not be using multiple availability zones. Maybe you are focusing on a geographic location or network performance is not on the top of your small team's list. But most of these will be your top concerns some day. Your code should be completely independent of the execution environment and deployable to everywhere. </p>

<p>Don't assume anything and with Lambda, you can't.</p>]]></content:encoded></item><item><title><![CDATA[Absurdly Simple Blog Hosting]]></title><description><![CDATA[<p>This website was once a single static page in my <a href="https://www.dropbox.com">Dropbox</a> and hosted with absurdly genius <a href="https://www.site44.com">site44</a>. Then I tried bunch of different options, including <a href="http://www.squarespace.com">Squarespace</a> and <a href="https://medium.com">Medium</a>, and circled back to static sites, to elegant <a href="https://pages.github.com">GitHub Pages</a>. Running a full-time, even a tiny free tier AWS EC2, server is</p>]]></description><link>http://localhost:2368/absurdly-simple-blog-hosting/</link><guid isPermaLink="false">4399a8d4-75c7-4f3a-b1f5-fa63dcabea47</guid><category><![CDATA[hacks]]></category><category><![CDATA[blogging]]></category><category><![CDATA[ghost]]></category><category><![CDATA[github pages]]></category><dc:creator><![CDATA[Engin Dogusoy]]></dc:creator><pubDate>Wed, 09 Dec 2015 08:02:28 GMT</pubDate><content:encoded><![CDATA[<p>This website was once a single static page in my <a href="https://www.dropbox.com">Dropbox</a> and hosted with absurdly genius <a href="https://www.site44.com">site44</a>. Then I tried bunch of different options, including <a href="http://www.squarespace.com">Squarespace</a> and <a href="https://medium.com">Medium</a>, and circled back to static sites, to elegant <a href="https://pages.github.com">GitHub Pages</a>. Running a full-time, even a tiny free tier AWS EC2, server is such a waste to serve a static "About" page and a couple of blog posts. GitHub Pages is minimalistic and pretty much tailored for this purpose; it is free, has custom domain support and bunch of easily modifiable free themes and best of all I write with <a href="https://daringfireball.net/projects/markdown/">markdown</a> and push directly to GitHub.</p>

<p>Last week I decided to write more frequently about AWS and Android development. Even though blogging on GitHub Pages is totally possible with <a href="https://jekyllrb.com">jekyll</a>, I didn't like the setup process. I wanted a simple interface to change most basic settings and write posts in markdown. Something like <a href="https://ghost.org">Ghost</a> served on GitHub Pages.</p>

<h3 id="enterbuster">Enter Buster</h3>

<p><a href="https://github.com/axitkhurana/buster">Buster</a> is Akshit 
Khurana's hack that takes a running Ghost domain as the input, crawls all pages, turns them into static pages and pushes them to your GitHub repo to be served over GitHub Pages. Brute force static site generator indeed!</p>

<h3 id="setup">Setup</h3>

<ol>
<li>Ordinary GitHub Pages Setup <br>
a. Create a GitHub repo with name: your-username.github.io <br>
b. Check <a href="https://help.github.com/categories/github-pages-basics/">here</a> to setup a custom domain  </li>
<li>Ordinary local Ghost setup <br>
a. <a href="http://support.ghost.org/installation/">http://support.ghost.org/installation/</a> <br>
b. Your local ghost instance should be running at <a href="http://localhost:2368/">http://localhost:2368/</a> <br>
c. (Optional) Download some <a href="http://www.allghostthemes.com">themes</a> and drop them in content/themes folder in your local Ghost folder. Restart server and change your theme from Ghost admin page.  </li>
<li>Buster Magic <br>
a. Install Buster with <code>pip install buster</code> <br>
b. <code>buster setup --dir=&lt;path to local github pages repo&gt;</code> <br>
c. <code>buster generate --domain=&lt;local-ghost-address&gt; --dir=&lt;path to local github pages repo&gt;</code> <br>
d. <code>buster add-domain &lt;custom-domain-name&gt; --dir=&lt;path to local github pages repo&gt;</code> (optional and needed only once) <br>
e. <code>buster deploy --dir=&lt;path to local github pages repo&gt;</code></li>
</ol>

<p>Steps are pretty self-explanatory; setup prepares your repo, generate crawls and creates static pages from your locally running Ghost instance, add-domain creates the CNAME file needed by GitHub for custom domain name mapping and deploy is just a fancy name for committing and pushing everything to your repo. Next time you want to post something run Ghost, finish your change, run <code>buster generate</code> and <code>buster deploy</code>.</p>

<p>Kudos Akshit for this brilliant hack, now I don't have a good reason to be lazy.</p>

<p><strong>For all commands Buster uses/creates a folder called _static by default. I used --dir command to specify my git repo.</strong> </p>]]></content:encoded></item><item><title><![CDATA[AWS Lambda : Missing piece of AWS Orchestration]]></title><description><![CDATA[<p>Last winter I was working on a small internal tool; one that should pull some files from an S3 folder sanitize and aggregate them and drop them in another S3 folder, no more than 10 lines of code. Running an EC2 instance, even a tiny one, to handle couple of</p>]]></description><link>http://localhost:2368/aws-lambda-missing-piece-of-aws-orchestration/</link><guid isPermaLink="false">408c6817-bf0c-4bfb-b5f9-c1a82d2824be</guid><category><![CDATA[aws]]></category><category><![CDATA[lambda]]></category><category><![CDATA[orchestration]]></category><dc:creator><![CDATA[Engin Dogusoy]]></dc:creator><pubDate>Tue, 08 Dec 2015 07:03:13 GMT</pubDate><content:encoded><![CDATA[<p>Last winter I was working on a small internal tool; one that should pull some files from an S3 folder sanitize and aggregate them and drop them in another S3 folder, no more than 10 lines of code. Running an EC2 instance, even a tiny one, to handle couple of calls per day, each running less than 5 seconds, was just wasteful. Spending a single minute every day to check it is health would’ve taken longer than the actual job at hand. Setting up a Data Pipeline with a ShellCommandActivity was almost equally wasteful and not responsive enough. Setting up a job queue and some webhooks would have taken unnecessarily long development time for such a simple job. AWS was missing its trigger.</p>

<p>I was so happy when I read about then newly released Lambda. I didn’t know node.js, console and S3 bucket notifications had a couple of bugs and develop-test cycle was cumbersome, but it didn’t matter. Lambda was the most elegant solution; it was there when I needed and gone when it is done.</p>

<p>Since then Lambda came a long way; it got Python and Java in addition to node, has a much better console and some templates to start with, it is more reliable and some limitations are relaxed. It can be triggered on a schedule or by mobile devices now. And of course, it became best friends with AWS API Gateway to build serverless backends. Nowadays people build frameworks on top of it to create serverless applications.</p>

<p>Lambda is changing the notion of traditional backend in such a radical way that its other benefit; connecting AWS resources to each other in the most simplest way is just overshadowed. By making it possible to trigger Lambda from other services, Amazon simply increased value of all services that can interact with Lambda. It became truly “on demand”. I am using Lambda to make decisions as I pass data between services, start/stop services and sanitize some calls from mobile devices to our backend.</p>

<p>Next time you design a backend system or an internal tool, consider Lambda to be the glue that keeps your bigger blocks together.</p>]]></content:encoded></item><item><title><![CDATA[Understanding HIDs]]></title><description><![CDATA[<p>Mouses, keyboards, game controllers are every day devices we expect to work with our systems seamlessly. We don’t even have patience to download and install their drivers. We want them to work magically. Magical is convenient. But what is the main ingredient of magic?</p>

<p>I have a Ps4 lying</p>]]></description><link>http://localhost:2368/understanding-hids/</link><guid isPermaLink="false">1b9f1229-db80-4aaf-9363-ed36fbcfccbb</guid><category><![CDATA[hacks]]></category><category><![CDATA[demo]]></category><category><![CDATA[ps4]]></category><category><![CDATA[usb]]></category><category><![CDATA[hid]]></category><dc:creator><![CDATA[Engin Dogusoy]]></dc:creator><pubDate>Tue, 08 Dec 2015 06:59:47 GMT</pubDate><content:encoded><![CDATA[<p>Mouses, keyboards, game controllers are every day devices we expect to work with our systems seamlessly. We don’t even have patience to download and install their drivers. We want them to work magically. Magical is convenient. But what is the main ingredient of magic?</p>

<p>I have a Ps4 lying around for the past couple of weeks and honestly I am not excited about it at all. The controller, DualShock 4, is another story. I must give kudos to Sony for equipping this controller with various tricks and believing in developer’s creativity. As the platform owner, they have made the controller as interactive as they can and challenged developers to utilize these features in most creative ways. My weekend goal is to get to know Dualshock 4, particularly it’s touch-pad, without using a Playstation SDK (Because I don’t have one).</p>

<p>I’ve started my search with Tested’s article on using Ps4 as a PC controller. DS4Tool is an impressive tool that hides your DS4 behind a ,Windows-supported, Xbox 360 controller driver and as a result make it possible for you to use DS4 with PC games. Unfortunately I wasn’t able to find any source code so I ventured forth to a similar project; PS4PC.</p>

<p>PS4PC is a lightweight executable that maps PS4 touch-pad to your mouse. After playing with it for a while, now that I knew it is actually possible to use touch-pad on a PC, I was excited to learn more about USB devices.</p>

<p>Couple of hours of quick-and-dirty Google searches and going over partially helpful sources, wikis and code pieces, I knew good enough to say a couple of lines about USB devices and HIDs. The interaction between a USB device and a PC depends on simply polling. PC frequently “reads” the device and as a result the device returns a report, represented as a byte array, which holds information about device state. Of course it is a two-way street, PC can create a report and “write” to device to trigger features such as haptic feedback.</p>

<p>OK, now that we know how communication works, how do we specify content? That’s where our best friend HID comes in. HID is simply a contract between device producer and it’s future owners. It is, in a way, a map that explains meaning of each byte in the report. 6th byte may be the state of your left mouse button; either clicked or not. Of course, HIDs are pretty short and predictable for simpler USB devices such as regular mouses, but they may become beasts with devices such as DualShock 4. Realizing Sony has not released a public HID, my hopes for touch-pad integration were failing as I found out that some geniuses decided to decode HID on their own, great!</p>

<p>The rest was pretty simple; pick up an HID library project for C#, Java or your favorite language, find vendor and product ids for your device through Control Panel, write a simple program that reads your device in short time intervals and get the information you want by mapping bytes into booleans, integers, etc. using HID. One interesting characteristic with USB interaction is the concept of continuous information flow. Working mostly on mobile platforms nowadays, I tend to think event based interaction, someone tapping on a button, swiping, etc. However with USB devices there is always information coming in and it’s your job as the developer to decide what constitutes an event and react to it.</p>

<p>That’s about it; 5–6 hours, 2 pots of coffee, couple of mutterings and frustrations here there resulted in a DualShock 4 talking to a PC. If you are looking for an interesting weekend, pick your favorite USB device and try to see what lies under the driver, you may be surprised.</p>

<p><strong>Note:</strong> This experiment actually turned into a <a href="https://www.youtube.com/watch?v=enVsFl9Lu3U">demo</a>!</p>]]></content:encoded></item></channel></rss>